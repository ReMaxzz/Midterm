Techniques Used

1. Classes and Object-Oriented Programming: Implemented Task and PriorityTask classes to model tasks with properties and methods.
2. Inheritance and Polymorphism: PriorityTask extends Task, demonstrating inheritance. Method overriding is used for markCompleted().
3. Type Annotations and Interfaces: Used TypeScript's type system to define interfaces (e.g., TeamMember) and ensure type safety throughout the code.
4. Generics: Implemented a generic Queue<T> class to demonstrate type-safe data structures.
5. Functions and Higher-Order Functions: Created createTaskUpdater as a higher-order function to demonstrate functional programming concepts.
6. Asynchronous Programming: Implemented fetchTasks() using async/await and Promises to simulate API calls.
7. Array Methods: Utilized map(), filter(), and reduce() for data processing tasks.
8. rror Handling: Implemented try/catch blocks in parseTaskData() and fetchTasks() to handle potential errors gracefully.
9. Modules and Imports/Exports: Separated utility functions into a separate module (taskUtils.ts) and imported them in the main file (index.ts).

Problem-Solving Approach

1. Modular Design: Broke down the problem into smaller, manageable parts corresponding to each concept.
2. Progressive Implementation: Started with basic classes and gradually added more complex features.
3. Type Safety: Leveraged TypeScript's type system to catch potential errors early in development.
4. Code Reusability: Used inheritance, interfaces, and generics to create reusable and extensible code.
5. Error Handling: Implemented robust error handling to ensure the application can gracefully handle unexpected situations.

โค้ดส่วนใหญ่มาจาก ChatGPT และนำมาทำความเข้าใจและปรับให้เป็นของตัวเอง ขอบคุณครับ